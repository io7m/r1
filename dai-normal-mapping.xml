<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright © 2014 <code@io7m.com> http://io7m.com

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  -->

<s:section 
  xml:id="r1.dai.normal-mapping"
  xmlns:s="http://schemas.io7m.com/structural/2.1.0"
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <s:section-title>Normal Mapping</s:section-title>
  <s:section-contents/>

  <s:subsection xml:id="r1.dai.normal-mapping.overview">
    <s:subsection-title>Overview</s:subsection-title>
    <s:paragraph>
      The <s:term s:type="package">io7m-r1</s:term> package
      supports the use of <s:term s:type="term">tangent-space normal mapping</s:term>
      to allow for per-pixel control over the surface normal of rendered triangles.
      This allows for meshes to appear to have very complex surface details without
      requiring those details to actually be rendered as triangles within the scene.
    </s:paragraph>
  </s:subsection>

  <s:subsection xml:id="r1.dai.normal-mapping.tangent-space">
    <s:subsection-title>Tangent Space</s:subsection-title>
    <s:paragraph>
      Conceptually, there is a three-dimensional coordinate system based
      at each vertex, formed by three orthonormal basis vectors: The vertex <s:term s:type="term">normal</s:term>,
      <s:term s:type="term">tangent</s:term> and <s:term s:type="term">bitangent</s:term>
      vectors. The <s:term s:type="term">normal</s:term> vector is a the vector perpendicular
      to the surface at that vertex. The <s:term s:type="term">tangent</s:term> and
      <s:term s:type="term">bitangent</s:term> vectors are parallel to the surface, and
      each vector is obviously perpendicular to the other two vectors. This coordinate
      space is often referred to as <s:term s:type="term">tangent space</s:term>. The
      <s:term s:type="term">normal</s:term> vector actually forms the 
      <s:term s:type="constant">Z</s:term> axis of the coordinate space, and this
      fact is central to the process of normal mapping. The coordinate system at
      each vertex may be left or right-handed depending on the arrangement of UV 
      coordinates at that vertex.
    </s:paragraph>
    <s:formal-item s:kind="examples">
      <s:formal-item-title>Vertex coordinate system</s:formal-item-title>
      <s:image s:source="images/normal.png">Vertex coordinate system</s:image>
    </s:formal-item>
  </s:subsection>

  <s:subsection xml:id="r1.dai.normal-mapping.tangent-bitangent-generation">
    <s:subsection-title>Tangent/Bitangent Generation</s:subsection-title>
    <s:paragraph>
      <s:term s:type="term">Tangent</s:term> and <s:term s:type="term">bitangent</s:term> 
      vectors can be generated by the modelling programs that artists use to
      create polygon meshes, but, additionally, the
      <s:link-external s:target="apidocs/com/io7m/r1/meshes/RMeshTangents.html">RMeshTangents</s:link-external>
      class can take an arbitrary mesh with only normal vectors and UV 
      coordinates and produce tangent and bitangent vectors. The full
      description of the algorithm used is given in
      <s:link-external s:target="http://www.mathfor3dgameprogramming.com/">Mathematics for 3D Game Programming and Computer Graphics, Third Edition</s:link-external>
      <s:footnote>
        See section 7.8.3, "Calculating tangent vectors".
      </s:footnote>,
      and also in an
      <s:link-external s:target="http://www.terathon.com/code/tangent.html">article</s:link-external>
      by the same author. The actual aim of tangent/bitangent generation
      is to produce a pair of orthogonal vectors that are oriented to the
      <s:term s:type="variable">x</s:term> and <s:term s:type="variable">y</s:term>
      axes of an arbitrary texture. In order to do achieve this,
      the generated vectors are oriented according to the UV 
      coordinates in the mesh.
    </s:paragraph>
    <s:paragraph>
      In the <s:term s:type="package">io7m-r1</s:term> package, the
      <s:term s:type="term">bitangent</s:term> vector is not actually stored in
      the mesh data, and the <s:term s:type="term">tangent</s:term> vector for 
      any given vertex is instead stored as a four-component vector.
      The reasons for this are as follows: Because the normal, tangent, and 
      bitangent vectors are known to be orthonormal, it should be possible to
      reconstruct any one of the three vectors given the other two at run-time. 
      This would eliminate the need to store one of the vectors and would
      reduce the size of mesh data (including the on-disk size, and the 
      size of mesh data allocated on the GPU) by a significant amount.
      Given any two orthogonal vectors <s:term s:type="constant">V0</s:term>
      and <s:term s:type="constant">V1</s:term>, a vector orthogonal to both
      can be calculated by taking the <s:term s:type="term">cross product</s:term>
      of both, denoted <s:term s:type="expression">(cross V0 V1)</s:term>. The
      problem here is that if <s:term s:type="constant">V0</s:term> is assumed
      to be the original normal vector <s:term s:type="constant">N</s:term>,
      and <s:term s:type="constant">V1</s:term> is assumed to be the original
      tangent vector <s:term s:type="constant">T</s:term>, there is no guarantee
      that <s:term s:type="expression">(cross N T)</s:term> will produce a
      vector equal to the original bitangent vector 
      <s:term s:type="constant">B</s:term>: There are two possible
      choices of value for <s:term s:type="constant">B</s:term> that differ
      only in the sign of their coordinate values.
    </s:paragraph>
    <s:paragraph>
      As an example, a triangle that will produce <s:term s:type="constant">T</s:term>
      and <s:term s:type="constant">B</s:term> vectors that form a right-handed
      coordinate system with the normal vector <s:term s:type="constant">N</s:term>
      (with UV coordinates indicated at each vertex):
    </s:paragraph>
    <s:formal-item s:kind="diagram">
      <s:formal-item-title>Tangent generation (RHC)</s:formal-item-title>
      <s:image s:source="images/tangent_gen_RHC.png">Tangent generation (Resulting in a right-handed coordinate system)</s:image>
    </s:formal-item>
    <s:paragraph>
      The same triangle will produce vectors that form a left-handed system when
      generating vectors for another vertex (note that the result of
      <s:term s:type="expression">(Vector3f.cross N T) = (Vector3f.negation B)</s:term>):
    </s:paragraph>
    <s:formal-item s:kind="diagram">
      <s:formal-item-title>Tangent generation (LHC)</s:formal-item-title>
      <s:image s:source="images/tangent_gen_LHC.png">Tangent generation (Resulting in a left-handed coordinate system)</s:image>
    </s:formal-item>
    <s:paragraph>
      However, if the
      original tangent vector <s:term s:type="constant">T</s:term> was augmented
      with a piece of extra information that indicated whether or not the result of
      <s:term s:type="expression">(cross N T)</s:term> needed to be inverted, then
      reconstructing <s:term s:type="constant">B</s:term> would be trivial.
      Therefore, the fourth component of the tangent vector <s:term s:type="constant">T</s:term>
      contains <s:term s:type="constant">1.0</s:term> if 
      <s:term s:type="expression">(cross N T) = B</s:term>, and
      <s:term s:type="constant">-1.0</s:term> if <s:term s:type="expression">(cross N T) = -B</s:term>.
      The bitangent vector can therefore be
      reconstructed by calculating <s:term s:type="expression">cross (N, T.xyz) * T.w</s:term>.
    </s:paragraph>
    <s:paragraph>
      With the three vectors <s:term s:type="expression">(T, B, N)</s:term>, it's now possible
      construct a <s:term s:type="expression">3x3</s:term> matrix that can transform arbitrary
      vectors in <s:link s:target="r1.dai.normal-mapping.tangent-space">tangent space</s:link>
      to <s:link s:target="r1.dai.coords.object-space">object space</s:link>:
    </s:paragraph>
    <s:formal-item s:kind="diagram">
      <s:formal-item-title>Tangent → Object matrix</s:formal-item-title>
      <s:image s:source="images/tangent_object_matrix.png">Tangent → Object matrix</s:image>
    </s:formal-item>
    <s:paragraph>
      With this matrix, it's now obviously possible to take an arbitrary vector in
      tangent space and transform it to object space. Then, with the
      current <s:term s:type="term">normal matrix</s:term> (object → eye),
      transform the object space vector all the way to 
      <s:link s:target="r1.dai.coords.eye-space">eye space</s:link> 
      in the same manner as ordinary per-vertex object space normal vectors. 
    </s:paragraph>
  </s:subsection>

  <s:subsection xml:id="r1.dai.normal-mapping.map">
    <s:subsection-title>Normal Maps</s:subsection-title>
    <s:paragraph>
      A <s:term s:type="term">normal map</s:term> is an ordinary RGB texture
      where each texel represents a tangent space normal vector. The 
      <s:term s:type="variable">x</s:term> coordinate is stored in the
      red channel, the <s:term s:type="variable">y</s:term> coordinate is
      stored in the green channel, and the <s:term s:type="variable">z</s:term>
      coordinate is stored in the blue channel. The original
      coordinate values are assumed to fall within the inclusive range
      <s:term s:type="expression">[-1.0, 1.0]</s:term>, and these values
      are mapped to the range <s:term s:type="expression">[0.0, 1.0]</s:term>
      before being encoded to a specific pixel format.
    </s:paragraph>
    <s:paragraph>
      As an example, the vector <s:term s:type="constant">(0.0, 0.0, 1.0)</s:term>
      is first mapped to <s:term s:type="constant">(0.5, 0.5, 1.0)</s:term> and
      then, assuming an image format with 8-bits of precision per color channel,
      encoded to <s:term s:type="constant">(0x7f, 0x7f, 0xff)</s:term>. This
      results in a pale blue color that is characteristic of tangent space
      normal maps:
    </s:paragraph>
    <s:formal-item s:kind="diagram">
      <s:formal-item-title>(0.0, 0.0, 1.0)</s:formal-item-title>
      <s:image s:source="images/normalmap_zerozeroone.png">(0.0, 0.0, 1.0)</s:image>
    </s:formal-item>
    <s:paragraph>
      Typically, tangent space normal maps are generated from a simple
      height maps: Greyscale images where <s:term s:type="constant">0.0</s:term>
      denotes the lowest possible height, and <s:term s:type="constant">1.0</s:term>
      indicates the highest possible height. There are multiple algorithms
      that are capable of generating normal vectors from height maps, but
      the majority of them work from the same basic principle: For a given
      pixel with value <s:term s:type="variable">h</s:term> at location 
      <s:term s:type="expression">(x, y)</s:term> in an image, the neighbouring
      pixel values at <s:term s:type="expression">(x - 1, y)</s:term>,
      <s:term s:type="expression">(x - 1, y - 1)</s:term>, 
      <s:term s:type="expression">(x + 1, y)</s:term>,
      <s:term s:type="expression">(x + 1, y + 1)</s:term> are compared 
      with <s:term s:type="variable">h</s:term>
      in order to determine the <s:term s:type="term">slope</s:term> between 
      the height values. As an example, the
      <s:link-external s:target="https://en.wikipedia.org/wiki/Prewitt_operator">Prewitt (3x3) operator</s:link-external>
      when used from the
      <s:link-external s:target="https://code.google.com/p/gimp-normalmap/">gimp-normalmap</s:link-external>
      plugin will produce the following map from a given greyscale height map:
    </s:paragraph>
    <s:formal-item s:kind="diagram">
      <s:formal-item-title>Prewitt 3x3 normal map</s:formal-item-title>
      <s:image s:source="images/normalmap_fromheight.png">Prewitt 3x3 normal map</s:image>
    </s:formal-item>
    <s:paragraph>
      It is reasonably easy to infer the general directions of vectors from
      a visual inspection of a tangent space normal map alone. In the above
      image, the flat faces of the bricks are mostly pale blue. This is because the
      tangent space normal for that surface is pointing straight towards the
      viewer - mostly towards the positive <s:term s:type="variable">z</s:term>
      direction. The right edges of the bricks in the image are tinted with a
      pinkish hue - this indicates that the normal vectors at that pixel point
      mostly towards the positive <s:term s:type="variable">x</s:term> direction.
    </s:paragraph>
  </s:subsection>

  <s:subsection xml:id="r1.dai.normal-mapping.rendering">
    <s:subsection-title>Rendering With Normal Maps</s:subsection-title>
    <s:paragraph>
      As stated, the purpose of a normal map is to give per-pixel control
      over the surface normal for a given triangle during rendering. The
      process is as follows:
    </s:paragraph>
    <s:formal-item s:kind="specification">
      <s:formal-item-title>Rendering process</s:formal-item-title>
      <s:list-ordered>
        <s:list-item>
          Calculate the bitangent vector <s:term s:type="constant">B</s:term>
          from the <s:term s:type="constant">N</s:term> and
          <s:term s:type="constant">T</s:term> vectors. This step is
          performed on a per-vertex basis 
          (in the <s:term s:type="term">vertex shader</s:term>).
        </s:list-item>
        <s:list-item>
          Construct a <s:term s:type="constant">3x3</s:term> tangent → object
          matrix <s:term s:type="variable">M</s:term> 
          from the <s:term s:type="expression">(T, B, N)</s:term> vectors.
          This step is performed on a per-fragment basis 
          (in the <s:term s:type="term">fragment shader</s:term>)
          using the interpolated vectors calculated in the previous step.
        </s:list-item>
        <s:list-item>
          Sample a tangent space normal vector <s:term s:type="variable">P</s:term>
          from the current normal map.
        </s:list-item>
        <s:list-item>
          Transform the vector <s:term s:type="variable">P</s:term> with
          the matrix <s:term s:type="variable">M</s:term> by calculating
          <s:term s:type="expression">M * P</s:term>, resulting in
          an object space normal vector <s:term s:type="variable">Q</s:term>.
        </s:list-item>
        <s:list-item>
          Transform the vector <s:term s:type="variable">Q</s:term> to
          eye space, in the same manner that an ordinary per-vertex 
          normal vector would be (using the 
          <s:link s:target="r1.dai.coords.eye-space.normal-matrix">3x3 normal matrix</s:link>).
        </s:list-item>
      </s:list-ordered>
    </s:formal-item>
    <s:paragraph>
      Effectively, a "replacement" normal vector is sampled from the
      map, and transformed to object space using the existing
      <s:term s:type="expression">(T, B, N)</s:term> vectors. When
      the replacement normal vector is used when applying lighting,
      the effect is dramatic. Given a simple two-polygon
      square textured with the following albedo texture and normal map:
    </s:paragraph>
    <s:formal-item s:kind="example">
      <s:formal-item-title>Example albedo and normal maps</s:formal-item-title>
      <s:image s:source="images/normalmap_metalpanels.png">Example albedo and normal maps</s:image>
    </s:formal-item>
    <s:paragraph>
      The square when textured and normal mapped, with three spherical
      lights:
    </s:paragraph>
    <s:formal-item s:kind="example">
      <s:formal-item-title>Lit and normal mapped</s:formal-item-title>
      <s:image s:source="images/normalmap_applied.png">Lit and normal mapped</s:image>
    </s:formal-item>
    <s:paragraph>
      The same square with the same lights but missing the normal map:
    </s:paragraph>
    <s:formal-item s:kind="example">
      <s:formal-item-title>Lit and not normal mapped</s:formal-item-title>
      <s:image s:source="images/normalmap_none.png">Lit and not normal mapped</s:image>
    </s:formal-item>
  </s:subsection>

</s:section>
